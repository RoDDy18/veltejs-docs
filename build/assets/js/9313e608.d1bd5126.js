"use strict";(self.webpackChunkveltejs_docs=self.webpackChunkveltejs_docs||[]).push([[5036],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>h});var a=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function c(t,e){if(null==t)return{};var n,a,o=function(t,e){if(null==t)return{};var n,a,o={},r=Object.keys(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var s=a.createContext({}),l=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},p=function(t){var e=l(t.components);return a.createElement(s.Provider,{value:e},t.children)},m="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(t,e){var n=t.components,o=t.mdxType,r=t.originalType,s=t.parentName,p=c(t,["components","mdxType","originalType","parentName"]),m=l(n),d=o,h=m["".concat(s,".").concat(d)]||m[d]||u[d]||r;return n?a.createElement(h,i(i({ref:e},p),{},{components:n})):a.createElement(h,i({ref:e},p))}));function h(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var r=n.length,i=new Array(r);i[0]=d;var c={};for(var s in e)hasOwnProperty.call(e,s)&&(c[s]=e[s]);c.originalType=t,c[m]="string"==typeof t?t:o,i[1]=c;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2997:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:2},i="Actions",c={unversionedId:"velx/core-concepts/actions",id:"version-2.0.0-rc.0/velx/core-concepts/actions",title:"Actions",description:"Actions are similar to mutations, the differences being that:",source:"@site/versioned_docs/version-2.0.0-rc.0/velx/core-concepts/actions.md",sourceDirName:"velx/core-concepts",slug:"/velx/core-concepts/actions",permalink:"/velx/core-concepts/actions",draft:!1,editUrl:"https://github.com/RoDDy18/veltejs-docs/tree/main/versioned_docs/version-2.0.0-rc.0/velx/core-concepts/actions.md",tags:[],version:"2.0.0-rc.0",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"State",permalink:"/velx/core-concepts/state"},next:{title:"Mutations",permalink:"/velx/core-concepts/mutations"}},s={},l=[{value:"Dispatching Actions",id:"dispatching-actions",level:2},{value:"Composing Actions",id:"composing-actions",level:2}],p={toc:l},m="wrapper";function u(t){let{components:e,...n}=t;return(0,o.kt)(m,(0,a.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"actions"},"Actions"),(0,o.kt)("p",null,"Actions are similar to mutations, the differences being that:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Instead of mutating the state, actions commit mutations."),(0,o.kt)("li",{parentName:"ul"},"Actions can contain arbitrary asynchronous operations.")),(0,o.kt)("p",null,"Let's register a simple action:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const store = velX({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count = state.count + 1\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit("increment")\n    }\n  }\n})\n')),(0,o.kt)("p",null,"Action handlers receive a context object which exposes the same set of methods/properties on the store instance, so you can call ",(0,o.kt)("inlineCode",{parentName:"p"},"context.commit")," to commit a mutation, or access the state via ",(0,o.kt)("inlineCode",{parentName:"p"},"context.state"),". We can even call other actions with ",(0,o.kt)("inlineCode",{parentName:"p"},"context.dispatch"),". "),(0,o.kt)("h2",{id:"dispatching-actions"},"Dispatching Actions"),(0,o.kt)("p",null,"Actions are triggered with the ",(0,o.kt)("inlineCode",{parentName:"p"},"store.dispatch")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'store.dispatch("increment")\n')),(0,o.kt)("p",null,"This may look silly at first sight: if we want to increment the count, why don't we just call ",(0,o.kt)("inlineCode",{parentName:"p"},'store.commit("increment")')," directly? Remember that ",(0,o.kt)("strong",{parentName:"p"},"mutations have to be synchronous"),". Actions don't. We can perform ",(0,o.kt)("strong",{parentName:"p"},"asynchronous")," operations inside an action:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'actions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit("increment")\n    }, 1000)\n  }\n}\n')),(0,o.kt)("p",null,"Dispatching actions with a payload:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'store.dispatch("increment", 10)\n')),(0,o.kt)("p",null,"In this example, ",(0,o.kt)("inlineCode",{parentName:"p"},"10")," is the payload we are passing into the action, and we are calling an action called ",(0,o.kt)("inlineCode",{parentName:"p"},"increment"),", and that action is identified with it's action key ",(0,o.kt)("inlineCode",{parentName:"p"},'"increment"')),(0,o.kt)("p",null,"Actions support object payload format dispatch:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'// dispatch with an object payload\nstore.dispatch("increment", {\n  amount: 10\n})\n')),(0,o.kt)("p",null,"A more practical example of real-world actions would be an action to checkout a shopping cart, which involves ",(0,o.kt)("strong",{parentName:"p"},"calling an async API")," and ",(0,o.kt)("strong",{parentName:"p"},"committing multiple mutations"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"actions: {\n  checkout ({ commit, state }, products) {\n    // save the items currently in the cart\n    const savedCartItems = [...state.cart.added]\n    // send out checkout request, and optimistically\n    // clear the cart\n    commit(CHECKOUT_REQUEST)\n    // the shop API accepts a success callback and a failure callback\n    shop.buyProducts(\n      products,\n      // handle success\n      () => commit(CHECKOUT_SUCCESS),\n      // handle failure\n      () => commit(CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n")),(0,o.kt)("p",null,"Note we are performing a flow of asynchronous operations, and recording the side effects (state mutations) of the action by committing them."),(0,o.kt)("h2",{id:"composing-actions"},"Composing Actions"),(0,o.kt)("p",null,"Actions are often asynchronous, so how do we know when an action is done? And more importantly, how can we compose multiple actions together to handle more complex async flows?"),(0,o.kt)("p",null,"The first thing to know is that ",(0,o.kt)("inlineCode",{parentName:"p"},"store.dispatch")," can handle Promise returned by the triggered action handler and it also returns Promise:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'actions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit("someMutation")\n        resolve()\n      }, 1000)\n    })\n  }\n}\n')),(0,o.kt)("p",null,"Now you can do:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'store.dispatch("actionA").then(() => {\n  // ...\n})\n')),(0,o.kt)("p",null,"And also in another action:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'actions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch("actionA").then(() => {\n      commit("someOtherMutation")\n    })\n  }\n}\n')),(0,o.kt)("p",null,"Finally, if we make use of ",(0,o.kt)("a",{parentName:"p",href:"https://tc39.github.io/ecmascript-asyncawait/"},"async / await"),", we can compose our actions like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// assuming `getData()` and `getOtherData()` return Promises\n\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // wait for `actionA` to finish\n    commit('gotOtherData', await getOtherData())\n  }\n}\n")))}u.isMDXComponent=!0}}]);